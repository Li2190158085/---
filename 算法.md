# **蓝桥杯入门算法**

## 一 .原码 反码 补码

### 1.正数和负数的原码

> 这里我们以4为例子 ，由于大家电脑普遍为64位 而int 类型的大小为32 位，所以这里以4位 为例子
>
> 正数和负数的二进制原码**第一位表示符号位**，其余位 一样 ，***0**代表**正数** **1**代表**负数***。
>
> 4和-4的原码如下：

|  0   |  1   |  0   |  0   |
| :--: | :--: | :--: | :--: |

|  1   |  1   |  0   |  0   |
| :--: | :--: | :--: | :--: |

> 可以看到4 和 -4 的原码除了最高位也就是第一位不同 ，其余则相同。

------

### 2.正数和负数的反码

>在计算机中，原码，反码，补码的产生 其实是为了计算机能够处理正数和负数的操作，
>
>比如, 计算机如何处理 4 + (-4) 下面让我们站在上帝视角，自己操作一遍
>
>这里我们以八位进行表示，4 原码为（0000 0100） -4原码为（1000 0100） 

| 0    | 0    | 0    | 0    | 0    | 1    | 0    | 0    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 0    | 0    | 0    | 0    | 1    | 0    | 0    |
| 0    | 0    | 0    | 0    | 1    | 0    | 0    | 0    |

> 我们会发现 结果为 0000 1000 也就是8 没错，
>
> 如果按4 和-4 的原码来计算 那么4+(-4)=（0000 0100）+（1000 0100）=0000 1000=8

> 因此计算机提出了反码 ，正数的反码和原码相同，负数的反码则是负数的原码除了最高位也就是符号位不变，其他都取反
>
> 因此下面给出 4 和 -4 的 的反码，然后对反码进行相加。

| 0    | 0    | 0    | 0    | 0    | 1    | 0    | 0    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 1    | 1    | 1    | 1    | 0    | 1    | 1    |
| 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    |

> 我们发现，结果为 8个1（1111 1111）反码   ，由于这里是反码，我们取反 为 1000 0000 ，会发现答案为**-0**不是我们想要的**0**

------

### 3.正数和负数的补码

> 由于原码，反码，补码的出现是为了服务于负数，所以我们都知道 正数的原码 反码 补码 都相同
>
> 而负数的补码则是在负数的原码的基础上取反码在加1即可 。 **也就是反码+1**
>
> 那下面我们来用补码进行 4和 -4的相加

| 0    | 0    | 0    | 0    | 0    | 1    | 0    | 0    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 1    | 1    | 1    | 1    | 1    | 0    | 0    |
| 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |

>由于这里8位表示不够，答案应该为 0000 0000 这里是补码 ，多余的我们舍弃 我们转成反码为  11111 1111   
>
> 然后在加1 就为   0000 0000  这里左侧多出来俩0是舍弃 **答案为0**



>### 总结，正数的原，反，补码都相同，
>
>### 负数的原码:等于正数的原码改变最高位为1 ，就是4（0000 0100）-4（1000 0100）
>
>### 负数的反码：负数的原码除了最高位也就是符号位不变，其余取反
>
>### 负数的补码：负数的反码+1

------

## 二.一个数在二进制下有多少个1

### 1.&与运算

>与运算口诀 ，都为1则为1，其余则为0

>| 二进制数 1 | 运算符 | 二进制数 2 | 结果    |
>| ---------- | ------ | ---------- | ------- |
>| 0 1 0 0    | &      | 0 0 0 1    | 0 0 0 0 |

> 可以看到 4 &1 结果为 0，但是我们可以通过用右移运算符>> 来进行移位 把0100 右移一次为0010 再一次为0001 那么现在的0001&0001 结果就是1了，但是什么时候不移了呢，也就是当0100 右移了3次，变成 0000了也就是0 不移了。
>
> 所以我们可以写一个死循环，在这个数为0 的时候退出，如果这个数&1（0001）为1 那么就说明它有一个1。

> 下面附上java代码：

> ```Java
>     static int way(int n) {
>         int count = 0;
>         while (n != 0) {
>             if ((n & 1) == 1) {
>                 count++;
>             }
>             n = n >> 1;
>         }
>         return count;
>     }
> 
> ```

### 2.lowbit运算

> 什么是lowbit运算呢，从英文可以看出，low为低，bit为位的意思，
>
> 因此lowbit就是可以计算出一个数的最低位1往后的数
>
> 写为：5&（-5） 这也就是lowbit（5）求出5的最低位往后的数，我们来用补码进行&运算验证一下

| 0    | 1    | 0    | 1    |
| ---- | ---- | ---- | ---- |
| 1    | 0    | 1    | 1    |
| 0    | 0    | 0    | 1    |

>我们发现 结果为 补码  0001 为正数 所以原码为1 ，然后拿5来 剪0001 等于 4 ，在用4进行lowbit运算 为4    4-4=0 停止，一共运算了两次，也就是每次都减去最低位的1往后的数字。从而求出有几个 1.

> ```JAVA
>     static int lowbit(int n){
>             int count=0;
>         while (n!=0){
>             n-=n & (-n);
>             count++;
>         }
>         return count;
>     }
> }
> 
> ```

### 3.一个二进制下第n位的数是几

> ```java
>    static int way(int n,int index){
> 
>         return n >> (index - 1) & 1;
>     }
> ```

><img src="D:\代码文件\蓝桥杯入门算法Code\lanqiaoAlgorithm\pictures\二进制第n位为几.png" alt="代码截图"  />

>![](D:\代码文件\蓝桥杯入门算法Code\lanqiaoAlgorithm\pictures\二进制第n位为几.png)
>
>

## 三. 二分查找

